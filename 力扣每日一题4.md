# 1.1 种花问题

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。

示例 1:

输入: flowerbed = [1,0,0,0,1], n = 1
输出: True
示例 2:

输入: flowerbed = [1,0,0,0,1], n = 2
输出: False
注意:

数组内已种好的花不会违反种植规则。
输入的数组长度范围为 [1, 20000]。
n 是非负整数，且不会超过输入数组的大小。

==贪心==

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {

        int countZero = 0;
        int flowers = 0;
        int l = flowerbed.length;

        for(int i = 0; i < l; i++){
            if(i < l && flowerbed[i] == 0){
                countZero++;
            }else{
                int add = 0;
                if(countZero > 0){
                    if(countZero == i){
                        add = countZero / 2;
                    }else{
                        add = (countZero + 1) / 2 - 1;
                    }                        
                }
                flowers += add;
                countZero = 0;
            }
        }
        
        if(countZero > 0){
            if(countZero == l){
                flowers += (countZero + 1) /2; 
            }else{
                flowers += countZero / 2;
            }
        }

        return flowers >= n;
    }
}
```



# *1.2 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]
示例 3：

输入：nums = [1,-1], k = 1
输出：[1,-1]
示例 4：

输入：nums = [9,11], k = 2
输出：[11]
示例 5：

输入：nums = [4,-2], k = 2
输出：[4]


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length

==单调递减队列==

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int l = nums.length;
        int[] ans = new int[l - k + 1];

        Deque<int[]> deque = new LinkedList<>();

        for(int i = 0 ; i < k; i++){
            while(!deque.isEmpty() && deque.peekLast()[0] < nums[i]){
                deque.removeLast();
            }
            deque.addLast(new int[]{nums[i],i});
        }

        for(int j = 0; j < l - k; j++){
            ans[j] = deque.getFirst()[0];


            if(deque.getFirst()[1] == j){
                deque.removeFirst();
            }

            while(!deque.isEmpty() && deque.peekLast()[0] < nums[j + k]){
                deque.removeLast();
            }
            deque.addLast(new int[]{nums[j + k], j + k});

        }
        ans[l - k] = deque.getFirst()[0];

        return ans;

    }
}
```

==优先队列==

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; ++i) {
            pq.offer(new int[]{nums[i], i});
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
```



# 1.3 分隔链表

给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

 

示例：

输入：head = 1->4->3->2->5->2, x = 3
输出：1->2->2->4->3->5·

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
       
        ListNode cur = head;
        ListNode front = new ListNode(-1);
        ListNode frontfir = front;        
        ListNode back = new ListNode(-1);
        ListNode backfir = back;

        while(cur != null){
            if(cur.val < x){
                front.next = cur;
                front = front.next;          
            }else{
                back.next = cur;              
                back = back.next;
            }
            cur = cur.next;   
        }
        back.next = null;
        front.next = backfir.next;
        return frontfir.next;
    }
}
```



# 1.4 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

==暴力递归 指数时间==

==动态规划==

```java
class Solution {
    public int fib(int n) {
        if(n == 0 || n == 1){
            return n;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i < n + 1; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];

    }
}
```

==动态规划优化==

```java
class Solution {
    public int fib(int n) {
        if(n == 0 || n == 1){
            return n;
        }
        
        int p = 0;
        int q = 1;
        int r = 0;
        for(int i = 2; i < n + 1; i++){
            r = p + q;
            p = q;
            q = r;
        }
        return r;

    }
}
```



# 1.5 较大分组的位置

在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 s = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。

分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 "xxxx" 分组用区间表示为 [3,6] 。

我们称所有包含大于或等于三个连续字符的分组为 较大分组 。

找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。

 

示例 1：

输入：s = "abbxxxxzzy"
输出：[[3,6]]
解释："xxxx" 是一个起始于 3 且终止于 6 的较大分组。
示例 2：

输入：s = "abc"
输出：[]
解释："a","b" 和 "c" 均不是符合要求的较大分组。
示例 3：

输入：s = "abcdddeeeeaabbbcd"
输出：[[3,5],[6,9],[12,14]]
解释：较大分组为 "ddd", "eeee" 和 "bbb"
示例 4：

输入：s = "aba"
输出：[]

提示：

1 <= s.length <= 1000
s 仅含小写英文字母

```java
class Solution {
    public List<List<Integer>> largeGroupPositions(String s) {
        List<List<Integer>> ans = new ArrayList<>();

        int count = 1;
        int l = s.length();

        for(int i = 0; i < l; i++){
            if(i == l - 1 || s.charAt(i) != s.charAt(i + 1)){
                if(count > 2){
                    ans.add(Arrays.asList(i - count + 1,i));
                }
                count = 1;
            }else{
                count++;
            }            
        }
        return ans;
    }
}
```



# *1.6 除法求值

给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。

 

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

 

示例 1：

输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
示例 2：

输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
示例 3：

输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
输出：[0.50000,2.00000,-1.00000,-1.00000]


提示：

1 <= equations.length <= 20
equations[i].length == 2
1 <= Ai.length, Bi.length <= 5
values.length == equations.length
0.0 < values[i] <= 20.0
1 <= queries.length <= 20
queries[i].length == 2
1 <= Cj.length, Dj.length <= 5
Ai, Bi, Cj, Dj 由小写英文字母与数字组成

==bfs==

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int count = 0;
        Map<String, Integer> vars = new HashMap<>();
        int l = values.length;
        for(int i = 0; i < l; i++){
            if(!vars.containsKey(equations.get(i).get(0))){
                vars.put(equations.get(i).get(0), count++);
            }
            if(!vars.containsKey(equations.get(i).get(1))){
                vars.put(equations.get(i).get(1), count++);
            }
        }

        List<Pair>[] edges = new List[count];
        for(int i = 0; i < count; i++){
            edges[i] = new ArrayList<Pair>();
        }
        //构造图
        for(int i = 0; i < l; i++){
            edges[vars.get(equations.get(i).get(0))].add(new Pair(vars.get(equations.get(i).get(1)), values[i]));
            edges[vars.get(equations.get(i).get(1))].add(new Pair(vars.get(equations.get(i).get(0)), 1.0 / values[i]));
        }

        int n = queries.size();
        double[] ans = new double[n];

        for(int i = 0; i < n; i++){
            double res = -1.0;
            if(vars.containsKey(queries.get(i).get(0)) && vars.containsKey(queries.get(i).get(1))){
                int index1 = vars.get(queries.get(i).get(0));
                int index2 = vars.get(queries.get(i).get(1));
                if(index1 == index2){
                    res = 1.0;
                }else{
                    //bfs
                    double[] paths = new double[count];
                    paths[index1] = 1.0;
                    Queue<Integer> queue = new LinkedList<>();
                    queue.offer(index1);
                    
                    while(!queue.isEmpty()){
                        int node = queue.poll();
                        for(Pair pair : edges[node]){
                            if(paths[pair.index] == 0.0){
                                paths[pair.index] = paths[node] * pair.len;
                                queue.offer(pair.index);
                            } 
                        }
                        if(paths[index2] != 0.0){
                            res = paths[index2];
                            break;
                        }
                    }
                }
            }
            ans[i] = res;
        }
        return ans;
    }
}

class Pair{
    int index;
    double len;

    public Pair(int i, double l){
        this.index = i;
        this.len = l;
    }
}
```

==一种dfs==

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int count = 0;
        Map<String, Integer> vars = new HashMap<>();
        int l = values.length;
        for(int i = 0; i < l; i++){
            if(!vars.containsKey(equations.get(i).get(0))){
                vars.put(equations.get(i).get(0), count++);
            }
            if(!vars.containsKey(equations.get(i).get(1))){
                vars.put(equations.get(i).get(1), count++);
            }
        }

        List<Pair>[] edges = new List[count];
        for(int i = 0; i < count; i++){
            edges[i] = new ArrayList<Pair>();
        }
        //构造图
        for(int i = 0; i < l; i++){
            edges[vars.get(equations.get(i).get(0))].add(new Pair(vars.get(equations.get(i).get(1)), values[i]));
            edges[vars.get(equations.get(i).get(1))].add(new Pair(vars.get(equations.get(i).get(0)), 1.0 / values[i]));
        }

        int n = queries.size();
        double[] ans = new double[n];

        for(int i = 0; i < n; i++){
            double res = -1.0;
            if(vars.containsKey(queries.get(i).get(0)) && vars.containsKey(queries.get(i).get(1))){
                int index1 = vars.get(queries.get(i).get(0));
                int index2 = vars.get(queries.get(i).get(1));
                
                //dfs
                double[] mark = new double[count];
                Arrays.fill(mark, -1.0);
                mark[index1] = 1.0;
                dfs(edges, index1, index2, 1.0, mark);
                res = mark[index2];
                
            }
            ans[i] = res;
        }
        return ans;
    }

    public void dfs(List<Pair>[] edges, int start, int des, double sumPath, double[] mark){
        if(start == des){
            mark[des] = sumPath;
            return;
        }

        for(Pair pair : edges[start]){
            if(mark[pair.index] < 0){
                mark[pair.index] = sumPath * pair.len;
                dfs(edges, pair.index, des, sumPath * pair.len, mark);
            }

        }        
    }
}

class Pair{
    int index;
    double len;

    public Pair(int i, double l){
        this.index = i;
        this.len = l;
    }
}
```

==另一种dfs==

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int count = 0;
        Map<String, Integer> vars = new HashMap<>();
        int l = values.length;
        for(int i = 0; i < l; i++){
            if(!vars.containsKey(equations.get(i).get(0))){
                vars.put(equations.get(i).get(0), count++);
            }
            if(!vars.containsKey(equations.get(i).get(1))){
                vars.put(equations.get(i).get(1), count++);
            }
        }

        List<Pair>[] edges = new List[count];
        for(int i = 0; i < count; i++){
            edges[i] = new ArrayList<Pair>();
        }
        //构造图
        for(int i = 0; i < l; i++){
            edges[vars.get(equations.get(i).get(0))].add(new Pair(vars.get(equations.get(i).get(1)), values[i]));
            edges[vars.get(equations.get(i).get(1))].add(new Pair(vars.get(equations.get(i).get(0)), 1.0 / values[i]));
        }

        int n = queries.size();
        double[] ans = new double[n];

        for(int i = 0; i < n; i++){
            double res = -1.0;
            if(vars.containsKey(queries.get(i).get(0)) && vars.containsKey(queries.get(i).get(1))){
                int index1 = vars.get(queries.get(i).get(0));
                int index2 = vars.get(queries.get(i).get(1));
                
                //dfs
                boolean[] mark = new boolean[count];
                mark[index1] = true;
                res = dfs(edges, index1, index2, mark);
                
            }
            ans[i] = res;
        }
        return ans;
    }

    public double dfs(List<Pair>[] edges, int start, int des, boolean[] mark){
        if(start == des){
            return 1.0;
        }

        for(Pair pair : edges[start]){
            if(!mark[pair.index]){
                mark[pair.index] = true;
                double sum = pair.len * dfs(edges, pair.index, des, mark);
                if(sum > 0){
                    return sum;
                }
            }

        }
        return -1.0;        
    }
}

class Pair{
    int index;
    double len;

    public Pair(int i, double l){
        this.index = i;
        this.len = l;
    }
}
```

==Floyd算法==

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int nvars = 0;
        Map<String, Integer> variables = new HashMap<String, Integer>();

        int n = equations.size();
        for (int i = 0; i < n; i++) {
            if (!variables.containsKey(equations.get(i).get(0))) {
                variables.put(equations.get(i).get(0), nvars++);
            }
            if (!variables.containsKey(equations.get(i).get(1))) {
                variables.put(equations.get(i).get(1), nvars++);
            }
        }
        double[][] graph = new double[nvars][nvars];
        for (int i = 0; i < nvars; i++) {
            Arrays.fill(graph[i], -1.0);
        }
        for (int i = 0; i < n; i++) {
            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
            graph[va][vb] = values[i];
            graph[vb][va] = 1.0 / values[i];
        }

        for (int k = 0; k < nvars; k++) {
            for (int i = 0; i < nvars; i++) {
                for (int j = 0; j < nvars; j++) {
                    if (graph[i][k] > 0 && graph[k][j] > 0) {
                        graph[i][j] = graph[i][k] * graph[k][j];
                    }
                }
            }
        }

        int queriesCount = queries.size();
        double[] ret = new double[queriesCount];
        for (int i = 0; i < queriesCount; i++) {
            List<String> query = queries.get(i);
            double result = -1.0;
            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
                if (graph[ia][ib] > 0) {
                    result = graph[ia][ib];
                }
            }
            ret[i] = result;
        }
        return ret;
    }
}

```

==带权并查集==

这也就是算法书中的Union-Find算法

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int nvars = 0;
        Map<String, Integer> variables = new HashMap<String, Integer>();

        int n = equations.size();
        for (int i = 0; i < n; i++) {
            if (!variables.containsKey(equations.get(i).get(0))) {
                variables.put(equations.get(i).get(0), nvars++);
            }
            if (!variables.containsKey(equations.get(i).get(1))) {
                variables.put(equations.get(i).get(1), nvars++);
            }
        }
        int[] f = new int[nvars];
        double[] w = new double[nvars];
        Arrays.fill(w, 1.0);
        for (int i = 0; i < nvars; i++) {
            f[i] = i;
        }

        for (int i = 0; i < n; i++) {
            int va = variables.get(equations.get(i).get(0)), vb = variables.get(equations.get(i).get(1));
            merge(f, w, va, vb, values[i]);
        }
        int queriesCount = queries.size();
        double[] ret = new double[queriesCount];
        for (int i = 0; i < queriesCount; i++) {
            List<String> query = queries.get(i);
            double result = -1.0;
            if (variables.containsKey(query.get(0)) && variables.containsKey(query.get(1))) {
                int ia = variables.get(query.get(0)), ib = variables.get(query.get(1));
                int fa = findf(f, w, ia), fb = findf(f, w, ib);
                if (fa == fb) {
                    result = w[ia] / w[ib];
                }
            }
            ret[i] = result;
        }
        return ret;
    }

    public void merge(int[] f, double[] w, int x, int y, double val) {
        int fx = findf(f, w, x);
        int fy = findf(f, w, y);
        f[fx] = fy;
        w[fx] = val * w[y] / w[x];
    }

    public int findf(int[] f, double[] w, int x) {
        if (f[x] != x) {
            int father = findf(f, w, f[x]);
            w[x] = w[x] * w[f[x]];
            f[x] = father;
        }
        return f[x];
    }
}
```



# 1.7 省份数量

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

 

示例 1：


输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2
示例 2：


输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出：3


提示：

1 <= n <= 200
n == isConnected.length
n == isConnected[i].length
isConnected[i][j] 为 1 或 0
isConnected[i][i] == 1
isConnected[i][j] == isConnected[j][i]

==并查集==

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        
        int[] f = new int[n];

        for(int i = 0; i < n; i++){
            f[i] = i;
        }

        for(int i = 0; i < n; i++){
            for(int j = i; j < n; j++){
                if(isConnected[i][j] == 1){
                    union(f, i, j);
                }
            }
        }

        int count = 0;
        for(int k = 0; k < n; k++){
            if(f[k] == k){
                count++;
            }          
        }
        return count;
    }

    public void union(int[] f, int i, int j){
        int fi = findf(f, i);
        int fj = findf(f, j);
        f[fi] = fj;
    }

    public int findf(int[] f, int i){
        if(f[i] != i){
            int father = findf(f, f[i]);
            f[i] = father;
        }
        return f[i];
    }
}
```

==dfs==

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] mark = new boolean[n];
        int ans = 0;

        for(int i = 0; i < n; i++){
            if(!mark[i]){
                mark[i] = true;
                dfs(isConnected, mark, n, i);
                ans++;
            }
        }
        return ans;
        
    }

    public void dfs(int[][] isConnected, boolean[] mark, int n, int i){
        for(int k = 0; k < n; k++){
            if(isConnected[i][k] == 1 && !mark[k]){
                mark[k] = true;
                dfs(isConnected, mark, n, k);
            }

        }

    }   
}
```

==bfs==

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        boolean[] mark = new boolean[n];
        int ans = 0;
        
        Queue<Integer> queue = new LinkedList<>();
       
       for(int j = 0; j < n; j++){
           if(!mark[j]){
               ans++;
               queue.offer(j);
               while(!queue.isEmpty()){
                    int node = queue.poll();
                    for(int i = 0; i < n; i++){
                        if(isConnected[i][node] == 1 && !mark[i]){
                            mark[i] = true;
                            queue.offer(i);
                        }
                    }         
                }
           }

       }
        return ans;        
    }   
}
```



# 1.8 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;

        for(int i = 0; i < (k % n); i++){
            int last = nums[n - 1];
            for(int j = n - 1; j > 0; j--){
                nums[j] = nums[j - 1];
            }
            nums[0] = last;

        }
    }
}
```

==双翻转==

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k , n - 1);

    }

    public void reverse(int[] nums, int start, int end){
        while(start < end){
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }

    }
}
```



# 1.10 汇总区间

给定一个无重复元素的有序整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b


示例 1：

输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
示例 2：

输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
示例 3：

输入：nums = []
输出：[]
示例 4：

输入：nums = [-1]
输出：["-1"]
示例 5：

输入：nums = [0]
输出：["0"]


提示：

0 <= nums.length <= 20
-231 <= nums[i] <= 231 - 1
nums 中的所有值都 互不相同
nums 按升序排列

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        int l = nums.length;
        List<String> ans = new ArrayList<>();
        if(l == 0){
            return ans;
        }

        int min = nums[0];
        int max = nums[0];

        for(int i = 1; i < l; i++){
            if(nums[i] == max + 1){
                max = nums[i];
            }else{
                if(min == max){
                    ans.add("" + min);
                }else{
                    ans.add("" + min + "->" + max);
                }
                min = nums[i];
                max = nums[i];
            }
        }

        if(min == max){
            ans.add("" + min);
        }else{
            ans.add("" + min + "->" + max);
        }

        return ans;

    }
}
```



# *1.11 交换字符串中的元素

给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。

你可以 任意多次交换 在 pairs 中任意一对索引处的字符。

返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。

 

示例 1:

输入：s = "dcab", pairs = [[0,3],[1,2]]
输出："bacd"
解释： 
交换 s[0] 和 s[3], s = "bcad"
交换 s[1] 和 s[2], s = "bacd"
示例 2：

输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]
输出："abcd"
解释：
交换 s[0] 和 s[3], s = "bcad"
交换 s[0] 和 s[2], s = "acbd"
交换 s[1] 和 s[2], s = "abcd"
示例 3：

输入：s = "cba", pairs = [[0,1],[1,2]]
输出："abc"
解释：
交换 s[0] 和 s[1], s = "bca"
交换 s[1] 和 s[2], s = "bac"
交换 s[0] 和 s[1], s = "abc"


提示：

1 <= s.length <= 10^5
0 <= pairs.length <= 10^5
0 <= pairs[i][0], pairs[i][1] < s.length
s 中只含有小写英文字母

==并查集==

```java
class Solution {
    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
        DisjointSetUnion dsu = new DisjointSetUnion(s.length());
        for (List<Integer> pair : pairs) {
            dsu.unionSet(pair.get(0), pair.get(1));
        }
        Map<Integer, List<Character>> map = new HashMap<Integer, List<Character>>();
        for (int i = 0; i < s.length(); i++) {
            int parent = dsu.find(i);
            if (!map.containsKey(parent)) {
                map.put(parent, new ArrayList<Character>());
            }
            map.get(parent).add(s.charAt(i));
        }
        for (Map.Entry<Integer, List<Character>> entry : map.entrySet()) {
            Collections.sort(entry.getValue(), new Comparator<Character>() {
                public int compare(Character c1, Character c2) {
                    return c2 - c1;//从大到小排序
                }
            });
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            int x = dsu.find(i);
            List<Character> list = map.get(x);
            sb.append(list.remove(list.size() - 1));
        }
        return sb.toString();
    }
}

class DisjointSetUnion {
    int[] f;
    int[] rank;
    int n;

    public DisjointSetUnion(int n) {
        this.n = n;
        rank = new int[n];
        Arrays.fill(rank, 1);
        f = new int[n];
        for (int i = 0; i < n; i++) {
            f[i] = i;
        }
    }

    public int find(int x) {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }

    public void unionSet(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx == fy) {
            return;
        }
        if (rank[fx] < rank[fy]) {
            int temp = fx;
            fx = fy;
            fy = temp;
        }
        rank[fx] += rank[fy];
        f[fy] = fx;
    }
}
```



# 1.12 项目管理

公司共有 n 个项目和  m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责。

group[i] 表示第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）小组可能存在没有接手任何项目的情况。

请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：

同一小组的项目，排序后在列表中彼此相邻。
项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。
如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个 空列表 。

 

示例 1：



输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
输出：[6,3,4,1,5,2,0,7]
示例 2：

输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
输出：[]
解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。


提示：

1 <= m <= n <= 3 * 104
group.length == beforeItems.length == n
-1 <= group[i] <= m - 1
0 <= beforeItems[i].length <= n - 1
0 <= beforeItems[i][j] <= n - 1
i != beforeItems[i][j]
beforeItems[i] 不含重复元素

```java
class Solution {
    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {
        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();
        for (int i = 0; i < n + m; ++i) {
            groupItem.add(new ArrayList<Integer>());
        }

        // 组间和组内依赖图
        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();
        for (int i = 0; i < n + m; ++i) {
            groupGraph.add(new ArrayList<Integer>());
        }
        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();
        for (int i = 0; i < n; ++i) {
            itemGraph.add(new ArrayList<Integer>());
        }

        // 组间和组内入度数组
        int[] groupDegree = new int[n + m];
        int[] itemDegree = new int[n];
        
        List<Integer> id = new ArrayList<Integer>();
        for (int i = 0; i < n + m; ++i) {
            id.add(i);
        }

        int leftId = m;
        // 给未分配的 item 分配一个 groupId
        for (int i = 0; i < n; ++i) {
            if (group[i] == -1) {
                group[i] = leftId;
                leftId += 1;
            }
            groupItem.get(group[i]).add(i);
        }
        // 依赖关系建图
        for (int i = 0; i < n; ++i) {
            int curGroupId = group[i];
            for (int item : beforeItems.get(i)) {
                int beforeGroupId = group[item];
                if (beforeGroupId == curGroupId) {
                    itemDegree[i] += 1;
                    itemGraph.get(item).add(i);   
                } else {
                    groupDegree[curGroupId] += 1;
                    groupGraph.get(beforeGroupId).add(curGroupId);
                }
            }
        }

        // 组间拓扑关系排序
        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); 
        if (groupTopSort.size() == 0) {
            return new int[0];
        }
        int[] ans = new int[n];
        int index = 0;
        // 组内拓扑关系排序
        for (int curGroupId : groupTopSort) {
            int size = groupItem.get(curGroupId).size();
            if (size == 0) {
                continue;
            }
            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));
            if (res.size() == 0) {
                return new int[0];
            }
            for (int item : res) {
                ans[index++] = item;
            }
        }
        return ans;
    }

    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {
        Queue<Integer> queue = new LinkedList<Integer>();
        for (int item : items) {
            if (deg[item] == 0) {
                queue.offer(item);
            }
        }
        List<Integer> res = new ArrayList<Integer>();
        while (!queue.isEmpty()) {
            int u = queue.poll(); 
            res.add(u);
            for (int v : graph.get(u)) {
                if (--deg[v] == 0) {
                    queue.offer(v);
                }
            }
        }
        return res.size() == items.size() ? res : new ArrayList<Integer>();
    }
}
```





# 1.13 冗余连接

在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
示例 2：

输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
注意:

输入的二维数组大小在 3 到 1000。
二维数组中的整数在1到N之间，其中N是输入数组的大小。

==并查集==

```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int nodesCount = edges.length;
        int[] parent = new int[nodesCount + 1];
        for (int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }
        for (int i = 0; i < nodesCount; i++) {
            int[] edge = edges[i];
            int node1 = edge[0], node2 = edge[1];
            if (find(parent, node1) != find(parent, node2)) {
                union(parent, node1, node2);
            } else {
                return edge;
            }
        }
        return new int[0];
    }

    public void union(int[] parent, int index1, int index2) {
        parent[find(parent, index1)] = find(parent, index2);
    }

    public int find(int[] parent, int index) {
        if (parent[index] != index) {
            parent[index] = find(parent, parent[index]);
        }
        return parent[index];
    }
}

```



# 1.14 可被5整除的二进制前缀

给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。

返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。

 

示例 1：

输入：[0,1,1]
输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
示例 2：

输入：[1,1,1]
输出：[false,false,false]
示例 3：

输入：[0,1,1,1,1,1]
输出：[true,false,false,false,true,false]
示例 4：

输入：[1,1,1,0,1]
输出：[false,false,false,false,false]


提示：

1 <= A.length <= 30000
A[i] 为 0 或 1

==模拟==

```java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] A) {
        int n = A.length;
        long pre = A[0];
        List<Boolean> ans = new ArrayList<>();
        ans.add(pre == 0 ? true : false);

        for(int i = 1; i < n; i++){
            pre = (pre * 2 + A[i]) % 5;

            ans.add(pre == 0 ? true : false);            
        }
        return ans;      
    }
}
```



# *1.15 移除最多的同行或同列石头

n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。

如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。

给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。

 

示例 1：

输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
输出：5
解释：一种移除 5 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,1] 同行。
2. 移除石头 [2,1] ，因为它和 [0,1] 同列。
3. 移除石头 [1,2] ，因为它和 [1,0] 同行。
4. 移除石头 [1,0] ，因为它和 [0,0] 同列。
5. 移除石头 [0,1] ，因为它和 [0,0] 同行。
石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。
示例 2：

输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
输出：3
解释：一种移除 3 块石头的方法如下所示：
1. 移除石头 [2,2] ，因为它和 [2,0] 同行。
2. 移除石头 [2,0] ，因为它和 [0,0] 同列。
3. 移除石头 [0,2] ，因为它和 [0,0] 同行。
石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。
示例 3：

输入：stones = [[0,0]]
输出：0
解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。


提示：

1 <= stones.length <= 1000
0 <= xi, yi <= 104
不会有两块石头放在同一个坐标点上

==本题实际上等价于找连通分量总数==

==并查集==

```java
class Solution {
    public int removeStones(int[][] stones) {
        int n = stones.length;

        Map<int[],Integer> nodemap = new HashMap<>();
        int num = 0;

        for(int i = 0; i < n; i++){
            int[] node = stones[i];
            nodemap.put(node, num++);
        }

        int[] uf = new int[num];
        for(int i = 0; i < num; i++){
            uf[i] = i;
        }

        for(int i = 0; i < n; i++){
            int[] node = stones[i];
            int no = nodemap.get(node);
            for(int j = i + 1; j < n; j++){
                if(stones[j][0] == node[0] || stones[j][1] == node[1]){
                    union(uf, no, nodemap.get(stones[j]));
                }
            }
        }

        int count = 0;
        for(int i = 0; i < num; i++){
            if(uf[i] == i){
                count++;
            }
        }
        return n - count;

    }

    public int findf(int[] uf, int node){
        if(uf[node] != node){
            uf[node] = findf(uf, uf[node]);
        }

        return uf[node];
    }

    public void union(int[] uf, int node1, int node2){
        uf[findf(uf,node1)] = findf(uf, node2);
    }
}
```



==并查集+优化建图==

把每个石头的横纵坐标相连

当然也可以用bfs和dfs

```java
class Solution {
    int[] f = new int[20001];

    public int removeStones(int[][] stones) {
        int n = stones.length;
        Arrays.fill(f, -1);

        for(int i = 0; i < n; i++){
           union(stones[i][0], stones[i][1] + 10000);
        }

        int count = 0;
        for(int j = 0; j < 20001; j++){
            if(f[j] == j){
                count++;
            }

        }

        return n - count;
    }

    public void union(int i1, int i2){
        f[findf(i1)] = findf(i2);
    }

    public int findf(int i){
        if(f[i] < 0){
            f[i] = i;
        }
        return f[i] == i ? i : findf(f[i]);
    }
}
```





# *1.18 账户合并

给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。

现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。

合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。

 

示例 1：

输入：
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
输出：
[["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
解释：
第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 "johnsmith@mail.com"。 
第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。
可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，
['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。


提示：

accounts的长度将在[1，1000]的范围内。
accounts[i]的长度将在[1，10]的范围内。
accounts[i][j]的长度将在[1，30]的范围内。

==并查集==

```java
class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map<String, Integer> emailToIndex = new HashMap<String, Integer>();
        Map<String, String> emailToName = new HashMap<String, String>();
        int emailsCount = 0;

        for (List<String> account : accounts) {
            String name = account.get(0);
            int size = account.size();
            for (int i = 1; i < size; i++) {
                String email = account.get(i);
                if (!emailToIndex.containsKey(email)) {
                    emailToIndex.put(email, emailsCount++);
                    emailToName.put(email, name);
                }
            }
        }

        int[] uf = new int[emailsCount];

        for(int i = 0; i < emailsCount; i++){
            uf[i] = i;
        }

        for(List<String> account : accounts){
            int size = account.size();
            for(int i = 2; i < size; i++){
                union(uf, emailToIndex.get(account.get(1)), emailToIndex.get(account.get(i)));
            }
        }

        Map<Integer,List<String>> indextoEmail = new HashMap<>();
        for(String email : emailToIndex.keySet()){
            int index = findf(uf, emailToIndex.get(email));
            List<String> acc = indextoEmail.getOrDefault(index, new ArrayList<String>());
            acc.add(email);
            indextoEmail.put(index, acc);
        }

        List<List<String>> ans = new ArrayList<>();

        for(List<String> list : indextoEmail.values()){
            Collections.sort(list);
            List<String> merge = new ArrayList<>();
            merge.add(emailToName.get(list.get(0)));
            for(String em : list){
                merge.add(em);
            }
            ans.add(merge);
        }
        return ans;

    }

    public void union(int[] uf, int n1, int n2){
        uf[findf(uf, n1)] = findf(uf, n2);
    }

    public int findf(int[] uf, int n){
        if(uf[n] != n){
            uf[n] = findf(uf, uf[n]);
        }
        return uf[n];
    }
}
```



# *1.19 连接所有点的最小费用

给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。

连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

![1611044059261](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1611044059261.png)

==寻找最小生成树==

==Prim算法的延时实现==

```java
class Solution {
    boolean[] mark;
    PriorityQueue<Edge> pq;
    int[][] points;
    int n;

    public int minCostConnectPoints(int[][] points) {
        this.points = points;
        n = points.length;
        int ans = 0;
        int count = 0;
        mark = new boolean[n];
        pq = new PriorityQueue<Edge>((e1,e2) -> {
           return e1.len - e2.len;
        });

        visit(0);
        while(!pq.isEmpty() && count < n - 1){
            Edge e = pq.poll();
            int v = e.x;
            int w = e.y;

            if(mark[v] && mark[w]){
                continue;
            }
            ans += e.len;
            count++;

            if(!mark[v]){
                visit(v);
            }
            if(!mark[w]){
                visit(w);
            }
        }

        return ans;

    }

    public void visit(int p){
        mark[p] = true;
        for(int i = 0; i < n; i++){
            if(i != p && !mark[i]){
                pq.offer(new Edge(i, p));
            }
        }
    }

    class Edge{
        int x;
        int y;
        int len;

        public Edge(int x, int y){
            this.x = x;
            this.y = y;
            this.len = Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
        }

    }
}


```

==Kruskal算法 并查集==

```java
class Solution {
    int[] uf;
    int[][] points;
    int n;
    PriorityQueue<Edge> pq;   

    public int minCostConnectPoints(int[][] points) {
        this.points = points;
        n = points.length;
        uf = new int[n];
        int ans = 0;
        int count = 0;
        for(int i = 0; i < n; i++){
            uf[i] = i;
        }

        pq = new PriorityQueue<Edge>((e1,e2) -> {
           return e1.len - e2.len;
        });

        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                pq.offer(new Edge(i, j));
            }
        }
        while(!pq.isEmpty() && count < n - 1){
            Edge e = pq.poll();
            int v = e.x;
            int w = e.y;

            if(find(v) == find(w)){
                continue;
            }
            union(v, w);
            ans += e.len;
            count++;
        }

        return ans;      

    }

    public int find(int x){
        if(uf[x] != x){
            uf[x] = find(uf[x]);
        }
        return uf[x];
    }

    public void union(int x, int y){
        uf[find(x)] = find(y);
    }

    

    class Edge{
        int x;
        int y;
        int len;

        public Edge(int x, int y){
            this.x = x;
            this.y = y;
            this.len = Math.abs(points[x][0] - points[y][0]) + Math.abs(points[x][1] - points[y][1]);
        }

    }
}


```





# *1.21 找到最小生成树里的关建边和伪关建边

你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。

请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。

请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。

![1611218065951](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1611218065951.png)

==并查集+ Kruskal算法 枚举==

```java
class Solution {
    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {
        int m = edges.length;
        int[][] newEdges = new int[m][4];
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < 3; ++j) {
                newEdges[i][j] = edges[i][j];
            }
            newEdges[i][3] = i;
        }
        Arrays.sort(newEdges, new Comparator<int[]>() {
            public int compare(int[] u, int[] v) {
                return u[2] - v[2];
            }
        });

        // 计算 value
        UnionFind ufStd = new UnionFind(n);
        int value = 0;
        for (int i = 0; i < m; ++i) {
            if (ufStd.unite(newEdges[i][0], newEdges[i][1])) {
                value += newEdges[i][2];
            }
        }

        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        for (int i = 0; i < 2; ++i) {
            ans.add(new ArrayList<Integer>());
        }
        
        for (int i = 0; i < m; ++i) {
            // 判断是否是关键边，没有这个边不行
            UnionFind uf = new UnionFind(n);
            int v = 0;
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(newEdges[j][0], newEdges[j][1])) {
                    v += newEdges[j][2];
                }
            }
            if (uf.setCount != 1 || (uf.setCount == 1 && v > value)) {
                ans.get(0).add(newEdges[i][3]);
                continue;
            }

            // 判断是否是伪关键边，没有这个边可以，有这个边也行
            uf = new UnionFind(n);
            uf.unite(newEdges[i][0], newEdges[i][1]);
            v = newEdges[i][2];
            for (int j = 0; j < m; ++j) {
                if (i != j && uf.unite(newEdges[j][0], newEdges[j][1])) {
                    v += newEdges[j][2];
                }
            }
            if (v == value) {
                ans.get(1).add(newEdges[i][3]);
            }
        }
      
        return ans;
    }
}

// 并查集模板
class UnionFind {
    int[] parent;
    int[] size;
    int n;
    // 当前连通分量数目
    int setCount;

    public UnionFind(int n) {
        this.n = n;
        this.setCount = n;
        this.parent = new int[n];
        this.size = new int[n];
        Arrays.fill(size, 1);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    public int findset(int x) {
        return parent[x] == x ? x : (parent[x] = findset(parent[x]));
    }
    
    public boolean unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            int temp = x;
            x = y;
            y = temp;
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    public boolean connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
}
```



# *1.29 最小体力消耗路径

你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

 ==最短路径 Dijstra算法==

```java
class Solution {
    int[][] direct = new int[][]{{1,0}, {-1, 0}, {0, 1}, {0, -1}};

    public int minimumEffortPath(int[][] heights) {
        int row = heights.length;
        int col = heights[0].length;

        boolean[] mark = new boolean[row * col];
        int[] dis = new int[row * col];
        Arrays.fill(dis, Integer.MAX_VALUE);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){
            public int compare(int[] a1, int[] a2){
                return a1[2] - a2[2];
            }
        });

        pq.offer(new int[]{0, 0, 0});
        dis[0] = 0;

        while(!pq.isEmpty()){
            int[] edge = pq.poll();
            int x = edge[0];
            int y = edge[1];
            int d = edge[2];
            int id = x * col + y;

            if(mark[id]){
                continue;
            }
            if(x == row - 1 && y == col - 1){
                break;
            }
            mark[id] = true;

            for(int i = 0; i < 4; i++){
                int nx = x + direct[i][0];
                int ny = y + direct[i][1];
                if(nx >= 0 && nx < row && ny >= 0 && ny < col && Math.max(d, Math.abs(heights[x][y] - heights[nx][ny])) < dis[nx * col + ny]){
                    dis[nx * col + ny] = Math.max(d, Math.abs(heights[x][y] - heights[nx][ny]));
                    pq.offer(new int[]{nx, ny, dis[nx * col + ny]});
                }

            }
        }

        return dis[row * col - 1];
    }
}
```

==并查集==

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int m = heights.length;
        int n = heights[0].length;
        List<int[]> edges = new ArrayList<int[]>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int id = i * n + j;
                if (i > 0) {
                    edges.add(new int[]{id - n, id, Math.abs(heights[i][j] - heights[i - 1][j])});
                }
                if (j > 0) {
                    edges.add(new int[]{id - 1, id, Math.abs(heights[i][j] - heights[i][j - 1])});
                }
            }
        }
        Collections.sort(edges, new Comparator<int[]>() {
            public int compare(int[] edge1, int[] edge2) {
                return edge1[2] - edge2[2];
            }
        });

        UnionFind uf = new UnionFind(m * n);
        int ans = 0;
        for (int[] edge : edges) {
            int x = edge[0], y = edge[1], v = edge[2];
            uf.unite(x, y);
            if (uf.connected(0, m * n - 1)) {
                ans = v;
                break;
            }
        }
        return ans;
    }
}

// 并查集模板
class UnionFind {
    int[] parent;
    int[] size;
    int n;
    // 当前连通分量数目
    int setCount;

    public UnionFind(int n) {
        this.n = n;
        this.setCount = n;
        this.parent = new int[n];
        this.size = new int[n];
        Arrays.fill(size, 1);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    public int findset(int x) {
        return parent[x] == x ? x : (parent[x] = findset(parent[x]));
    }
    
    public boolean unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            int temp = x;
            x = y;
            y = temp;
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    public boolean connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
}

```



# *1.30 水位上升的泳池中游泳

在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。

现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。

你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？

==自己写的dfs==

```java
class Solution {
    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    boolean[] mark;
    int n;

    public int swimInWater(int[][] grid) {
        n = grid.length;
        
        int cur;

        for(cur = 1; cur <= n * n - 1; cur++){
            if(cur < grid[0][0]){
                continue;
            }
            mark = new boolean[n * n];

            dfs(0, 0, cur, grid, grid[0][0]);

            if(mark[n * n - 1]){
                return cur;
            }
        }
        return -1;

    }

    public void dfs(int x, int y, int t, int[][] grid, int min){
        mark[x * n + y] = true;

        for(int i = 0; i < 4; i++){
            int nx = x + dir[i][0];
            int ny = y + dir[i][1];

            if(nx >= 0 && nx < n && ny >=0 && ny < n && !mark[nx * n + ny]){
                if(grid[nx][ny] > t){
                    continue;
                }
                dfs(nx, ny, t, grid, Math.min(min, grid[nx][ny]));  
            }

        }
    }
}


```

==并查集==

```java
class Solution {

    public int swimInWater(int[][] grid) {
        int n = grid.length;
        List<int[]> list = new ArrayList<>();

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i > 0){
                    list.add(new int[]{(i - 1)*n + j, i * n + j, Math.max(grid[i-1][j], grid[i][j])});
                }
                if(j > 0){
                    list.add(new int[]{i * n + j - 1, i * n + j, Math.max(grid[i][j - 1], grid[i][j])});
                }
            }
        }
        UnionFind uf = new UnionFind(n * n);
        Collections.sort(list, new Comparator<int[]>(){

            public int compare(int[] e1, int[] e2){
                return e1[2] - e2[2];
            }
        });

        int ans = 0;
        for(int[] edge : list){
            int x = edge[0];
            int y = edge[1];
            int d = edge[2];
            uf.unite(x, y);
            ans = Math.max(ans, d);

            if(uf.connected(0, n * n - 1)){
                return ans;
            }
        }

        return 0;
    }  
}
class UnionFind {
    int[] parent;
    int[] size;
    int n;
    // 当前连通分量数目
    int setCount;

    public UnionFind(int n) {
        this.n = n;
        this.setCount = n;
        this.parent = new int[n];
        this.size = new int[n];
        Arrays.fill(size, 1);
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
    }
    
    public int findset(int x) {
        return parent[x] == x ? x : (parent[x] = findset(parent[x]));
    }
    
    public boolean unite(int x, int y) {
        x = findset(x);
        y = findset(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            int temp = x;
            x = y;
            y = temp;
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    public boolean connected(int x, int y) {
        x = findset(x);
        y = findset(y);
        return x == y;
    }
}


```

